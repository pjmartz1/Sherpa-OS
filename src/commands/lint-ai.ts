import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { AILinter } from '../utils/ai-linter.js';
import { writeMarkdown } from '../utils/fs.js';
import * as path from 'path';

export const lintAiCommand = new Command('lint:ai')
  .description('Lint code for AI-specific anti-patterns and issues')
  .option('-f, --file <file>', 'Lint specific file instead of entire project')
  .option('-o, --output <file>', 'Save results to file')
  .option('--severity <level>', 'Minimum severity level (error, warning, info)', 'warning')
  .option('--fix', 'Automatically fix issues where possible (coming soon)')
  .action(async (options) => {
    const spinner = ora('Analyzing code for AI-specific issues...').start();
    
    try {
      const linter = new AILinter();
      let results: Record<string, any[]>;
      
      if (options.file) {
        spinner.text = `Analyzing ${options.file}...`;
        const issues = await linter.lintFile(path.resolve(options.file));
        results = issues.length > 0 ? { [options.file]: issues } : {};
      } else {
        spinner.text = 'Scanning project files...';
        results = await linter.lintProject();
      }
      
      spinner.stop();
      
      // Filter by severity
      const minSeverity = options.severity;
      const severityLevels = { error: 3, warning: 2, info: 1 };
      const minLevel = severityLevels[minSeverity as keyof typeof severityLevels] || 2;
      
      const filteredResults: Record<string, any[]> = {};
      for (const [file, issues] of Object.entries(results)) {
        const filtered = issues.filter(issue => 
          severityLevels[issue.severity as keyof typeof severityLevels] >= minLevel
        );
        if (filtered.length > 0) {
          filteredResults[file] = filtered;
        }
      }
      
      const output = linter.formatResults(filteredResults);
      console.log(output);
      
      if (options.output) {
        const reportContent = generateMarkdownReport(filteredResults);
        await writeMarkdown(options.output, reportContent);
        console.log(chalk.gray(`\nüìù Report saved to: ${options.output}`));
      }
      
      // Summary statistics
      const totalIssues = Object.values(filteredResults).reduce((sum, issues) => sum + issues.length, 0);
      const totalFiles = Object.keys(filteredResults).length;
      
      if (totalIssues > 0) {
        console.log(chalk.yellow(`\n‚ö†Ô∏è  Found ${totalIssues} AI-specific issues across ${totalFiles} files.`));
        console.log(chalk.blue('üí° These patterns are commonly generated by AI and should be reviewed.'));
      } else {
        console.log(chalk.green('\n‚úÖ No AI-specific issues detected!'));
      }
      
      if (options.fix) {
        console.log(chalk.gray('\nüîß Auto-fix feature coming soon...'));
      }
      
    } catch (error) {
      spinner.fail('AI linting failed');
      console.error(chalk.red(`Error: ${error}`));
      process.exit(1);
    }
  });

function generateMarkdownReport(results: Record<string, any[]>): string {
  const timestamp = new Date().toISOString();
  let totalIssues = 0;
  
  let report = `# AI Code Quality Report
*Generated: ${timestamp}*

## Summary
`;

  // Count issues by severity
  const severityCounts = { error: 0, warning: 0, info: 0 };
  for (const issues of Object.values(results)) {
    for (const issue of issues) {
      severityCounts[issue.severity as keyof typeof severityCounts]++;
      totalIssues++;
    }
  }

  report += `
- **Total Issues**: ${totalIssues}
- **Files Affected**: ${Object.keys(results).length}
- **Errors**: ${severityCounts.error}
- **Warnings**: ${severityCounts.warning}
- **Info**: ${severityCounts.info}

## Issues by File
`;

  for (const [file, issues] of Object.entries(results)) {
    report += `\n### ${file}\n`;
    
    issues.forEach(issue => {
      const icon = issue.severity === 'error' ? '‚ùå' : 
                  issue.severity === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
      report += `\n${icon} **Line ${issue.line}**: ${issue.message}\n`;
      if (issue.suggestion) {
        report += `   üí° *Suggestion*: ${issue.suggestion}\n`;
      }
    });
  }

  report += `\n## Common AI Patterns Detected

This report identifies code patterns that are commonly generated by AI tools and may indicate:

1. **Over-abstraction**: Unnecessary interfaces, generics, or design patterns
2. **Missing error handling**: Async functions without proper try-catch blocks
3. **Security issues**: Hardcoded secrets or credentials
4. **Type safety**: Usage of 'any' type instead of specific types
5. **Performance issues**: Inefficient array operations or loops

## Recommendations

- Review flagged patterns to ensure they align with your codebase standards
- Consider simplifying over-abstracted code
- Add proper error handling to async functions
- Move sensitive data to environment variables
- Use specific TypeScript types instead of 'any'
- Optimize performance-critical code sections

---
*Generated by Sherpa OS AI Linter*`;

  return report;
}